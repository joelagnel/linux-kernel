#!/usr/bin/env python3

# Copyright 2021 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# pylint: disable=missing-function-docstring

"""Chrome OS kernel configuration tool

Script to merge all configs and run 'make oldconfig' on it to wade out bad
juju, then split the configs into distro-commmon and flavour-specific parts

See this page for more details:
http://dev.chromium.org/chromium-os/how-tos-and-troubleshooting/kernel-configuration
"""

import argparse
import fnmatch
import glob
import logging
import os
import re
import shutil
import subprocess
import sys
import tempfile
import typing

MODES = ['oldconfig', 'olddefconfig', 'editconfig', 'genconfig']
ARCHES = ['x86_64', 'armel', 'arm64']
TOOLCHAIN_PREFIXES = {
    'x86_64': 'x86_64-cros-linux-gnu',
    'armel': 'armv7a-cros-linux-gnueabihf',
    'arm64': 'aarch64-cros-linux-gnu',
}


def splitconfig(srcdir: str) -> typing.Dict[str, str]:
    """Split and merge common configs

    Return dict of filename-to-contents.
    """
    allconfigs = {}

    # Parse config files.
    for config in os.listdir(srcdir):
        # Only config.*
        if not config.endswith('.config'):
            continue

        allconfigs[config] = set()

        for line in open(os.path.join(srcdir, config)):
            m = re.match(r'#*\s*CONFIG_(\w+)[\s=](.*)$', line)
            if not m:
                continue
            option, value = m.groups()
            allconfigs[config].add((option, value))

    # Split out common config options.
    common = None
    for config in allconfigs:
        if common is None:
            common = allconfigs[config].copy()
        else:
            common &= allconfigs[config]
    for config in allconfigs:
        allconfigs[config] -= common
    allconfigs['common.config'] = common

    ret = {}
    # Generate new splitconfigs.
    for config in allconfigs:
        contents = '#\n# Config options generated by splitconfig\n#\n'
        for option, value in sorted(list(allconfigs[config])):
            if value == 'is not set':
                contents += '# CONFIG_%s %s\n' % (option, value)
            else:
                contents += 'CONFIG_%s=%s\n' % (option, value)
        ret[config] = contents
    return ret


def die(msg: str = 'Aborting'):
    logging.error(msg)
    sys.exit(1)


def in_chroot() -> bool:
    return os.path.exists('/etc/cros_chroot_version')


def make_toolchain_args(arch: str) -> typing.List[str]:
    if in_chroot():
        prefix = TOOLCHAIN_PREFIXES[arch]
        ccompiler = prefix + '-clang'
    else:
        prefix = 'x86_64-linux-gnu'
        ccompiler = prefix + '-gcc'

    if not shutil.which(ccompiler):
        if in_chroot():
            die('%s not found. Try running "`sudo cros_setup_toolchains -t %s`"'
                % (ccompiler, prefix))
        else:
            die('%s not found. Try running inside chroot.' % ccompiler)

    return ['LD="ld.lld"',
            'CC=' + ccompiler,
            'CXX=' + prefix + '-g++',
            'CROSS_COMPILE=' + prefix + '-']

def getchar() -> str:
    # We don't want line-buffering, and shelling out to bash is much simpler
    # than messing with tty settings.
    return subprocess.check_output(
            ['bash', '-c', 'read -n 1 -s; echo "${REPLY}"']
            ).decode('utf-8').strip()


def editconfig_prompt(variant: str) -> bool:
    print('* %s: press <Enter> to edit, S to skip' % variant)
    return getchar() not in ('S', 's')


def filter_match(target: str, pattern: str) -> bool:
    return fnmatch.fnmatch(target, '*' + pattern + '*')


def is_editconfig_interactive(arch_flavour: str, prompt: bool,
                              pattern: str) -> bool:
    if filter_match(arch_flavour, pattern):
        if not prompt:
            return True
        return editconfig_prompt(arch_flavour)
    return False


def make_cmd(builddir: str, arch: str, target: str) -> typing.List[str]:
    make_args = make_toolchain_args(arch)
    kernelarch = 'arm' if arch == 'armel' else arch
    return (['make', '-j', 'O=' + builddir, 'ARCH=' + kernelarch] + make_args +
            [target, 'savedefconfig'])


def doit(args, tmpdir: str):
    for d in (os.getcwd(),
              os.path.abspath(os.path.join(
                  os.path.dirname(sys.argv[0]), '..', '..'))):
        if (os.path.exists(os.path.join(d, 'MAINTAINERS')) and
            os.path.exists(os.path.join(d, 'Makefile'))):
            srcdir = d
            logging.info('Using top kernel dir: %s', srcdir)
            break
    else:
        die('This does not appear to be a kernel source directory.')

    if not in_chroot() and not args.force:
        die('You must run this command inside the chroot')

    save_configs = args.mode == 'genconfig'

    procs = []
    for arch in ARCHES:
        for flavourconfig in glob.glob(os.path.join(srcdir, 'chromeos',
                                                    'config', arch,
                                                    '*.flavour.config')):
            flavour = os.path.basename(flavourconfig)
            builddir = os.path.join(tmpdir, 'build', arch, flavour)
            os.makedirs(builddir)

            # Merge base.config, common.config, <flavour>.flavour.config
            conf = '\n'.join(open(os.path.join(srcdir, f)).read() for f in [
                    'chromeos/config/base.config',
                    'chromeos/config/' + arch + '/common.config',
                    'chromeos/config/' + arch + '/' + flavour,
            ])
            open(os.path.join(builddir, '.config'), 'w').write(conf)

            interactive = False
            if args.mode == 'genconfig':
                mode = 'olddefconfig'
            elif args.mode == 'editconfig':
                interactive = is_editconfig_interactive(arch + '/' + flavour,
                                                        not args.yes,
                                                        args.filter)
                mode = 'menuconfig' if interactive else 'olddefconfig'
            else:
                if args.mode == 'oldconfig':
                    # 'oldconfig' may run into interactive prompts.
                    interactive = True
                mode = args.mode

            cmd = make_cmd(builddir, arch, mode)
            if interactive:
                logging.info('Starting interactive cmd: %s', ' '.join(cmd))
                ret = subprocess.run(cmd, check=False, cwd=srcdir)
                if ret.returncode:
                    die('cmd "%s" failed' % ' '.join(cmd))
            else:
                logging.info('Starting background cmd: %s', ' '.join(cmd))
                procs += [subprocess.Popen(cmd, cwd=srcdir,
                                           stdout=subprocess.PIPE,
                                           stderr=subprocess.PIPE)]

    for p in procs:
        ret = p.wait()
        if ret:
            assert p.stderr # Remind pytype we captured stderr.
            logging.error(p.stderr.read().decode('utf-8'))
            die('cmd %s failed' % p)

    if save_configs:
        keep_dir = 'CONFIGS'
        os.makedirs(keep_dir, exist_ok=True)

    logging.info('Generating splitconfigs')
    # All commands write to source directory for now.
    outdir = srcdir
    for arch in ARCHES:
        dest = os.path.join(tmpdir, arch)
        os.makedirs(dest)
        for flavourconfig in glob.glob(os.path.join(srcdir, 'chromeos/config',
                                       arch, '*.flavour.config')):
            flavour = os.path.basename(flavourconfig)
            builddir = os.path.join(tmpdir, 'build', arch, flavour)
            shutil.copy(os.path.join(builddir, 'defconfig'),
                        os.path.join(dest, flavour))
            if save_configs:
                shutil.copy(os.path.join(builddir, '.config'),
                            os.path.join(keep_dir, arch + '-' + flavour))
                shutil.copy(os.path.join(builddir, 'defconfig'),
                            os.path.join(keep_dir, arch + '-' +
                                         flavour + '.def'))
        # Find per-arch common items; flavour-unique options can be written out
        # immediately.
        for config, contents in splitconfig(dest).items():
            if config == 'common.config':
                open(tmpdir + '/' + arch + '.config', 'w').write(contents)
            else:
                open(outdir + '/chromeos/config/' + arch + '/' + config,
                     'w').write(contents)

    # Find cross-arch common items; common ones go to base.config, and unique
    # ones to <arch>/common.config.
    for config, contents in splitconfig(tmpdir).items():
        if config == 'common.config':
            open(outdir + '/chromeos/config/base.config', 'w').write(contents)
        else:
            assert config.endswith('.config')
            # Python3.9: arch = config.removesuffix('.config')
            arch = config[:-len('.config')]
            open(outdir + '/chromeos/config/' + arch + '/common.config',
                 'w').write(contents)


def main():
    parser = argparse.ArgumentParser()

    log_level_choices = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
    parser.add_argument(
        '--log_level', '-l',
        choices=log_level_choices,
        default='INFO'
    )
    parser.add_argument('--force', '-F', action='store_true',
                        help='Enable running outside the chroot')
    parser.add_argument('--filter', '-f', default='',
                        help='Only attempt to edit configs which match filter')
    parser.add_argument('--yes', '-y', action='store_true',
                        help='Edit all configs which match unconditionally')
    parser.add_argument('mode', choices=MODES, help='sub-command/mode')

    args = parser.parse_args()
    logging.basicConfig(level=args.log_level,
                        format='%(levelname)s - %(message)s')

    with tempfile.TemporaryDirectory() as tmpdir:
        doit(args, tmpdir)


sys.exit(main())
